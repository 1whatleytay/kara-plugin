{
  parserClass="me.desgroup.kara.KaraParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Kara"
  psiImplClassSuffix="Impl"
  psiPackage="me.desgroup.kara.psi"
  psiImplPackage="me.desgroup.kara.psi.impl"

  elementTypeHolderClass="me.desgroup.kara.psi.KaraTypes"
  elementTypeClass="me.desgroup.kara.psi.KaraElement"
  tokenTypeClass="me.desgroup.kara.psi.KaraToken"
}

root ::= (import|type|variable-strict|function-loose|COMMENT)*

import ::= IMPORT_DECL (OPEN_BRACE NAME CLOSE_BRACE)? literal-string

typename ::=
      typename-reference
    | typename-optional
    | typename-array
    | typename-primitive
    | typename-named

typename-reference ::= (OP_AND | (OP_MUL HINT_SHARED?)) (LET_DECL | VAR_DECL)? typename
typename-optional ::= (OP_QUESTION | OP_EXCLAM) typename
typename-array ::= OPEN_SQUARE typename typename-array-spec? CLOSE_SQUARE
typename-primitive ::= PRIMITIVE | ANY | NOTHING | NULL
typename-named ::= NAME

typename-array-spec ::=
      typename-array-spec-fixed
    | typename-array-spec-unbounded-sized
    | typename-array-spec-enumerable
    | typename-array-spec-unbounded

typename-array-spec-fixed ::= COLON NUMBER
typename-array-spec-unbounded ::= COLON
typename-array-spec-unbounded-sized ::= COLON expression
typename-array-spec-enumerable ::= COLON COLON

expression ::= expression-part expression-grouping? (binary expression-part)*

expression-part ::= unary* literal modifier*

expression-grouping ::= ternary | as | slash
ternary ::= OP_QUESTION expression COLON expression
as ::= AS_DECL typename
slash ::= BACKSLASH

unary ::= OP_EXCLAM | OP_SUB | OP_AND | OP_AT
binary ::=
      OP_ADD
    | OP_SUB
    | OP_MUL
    | OP_DIV
    | OP_MOD
    | OP_COMPARE
    | OP_NCOMPARE
    | OP_GE
    | OP_LE
    | OP_GREATER
    | OP_LESSER
    | OP_ANDAND
    | OP_OROR
    | OP_FALLBACK

literal ::=
      literal-parens
    | literal-array
    | literal-string
    | literal-special
    | literal-bool
    | literal-number
    | literal-new
    | literal-reference
literal-parens ::= OPEN_BRACE expression CLOSE_BRACE
literal-array ::= OPEN_SQUARE (expression COMMA?)* CLOSE_SQUARE
literal-string ::= QUOTE (STRING_PART | STRING_ESCAPE | STRING_INSERT)* QUOTE
literal-special ::= ANY | NOTHING | NULL
literal-bool ::= TRUE | FALSE
literal-number ::= NUMBER
literal-new ::= OP_MUL typename
literal-reference ::= NAME

modifier ::= modifier-call | modifier-index | modifier-dot
modifier-call ::= OPEN_BRACE (modifier-call-part COMMA?)* CLOSE_BRACE
modifier-call-part ::= (NAME COLON)? expression
modifier-index ::= OPEN_SQUARE expression CLOSE_SQUARE
modifier-dot ::= DOT (unary | NAME)

type ::= TYPE_DECL NAME type-body
type-body ::= type-alias-body | type-declaration-body
type-alias-body ::= OP_EQUALS typename
type-declaration-body ::= OPEN_BODY (variable-loose COMMA?)* CLOSE_BODY

variable ::= NAME ((typename? OP_EQUALS expression) | typename)
variable-loose ::= (LET_DECL | VAR_DECL)? variable
variable-strict ::= (LET_DECL | VAR_DECL) variable

function ::= NAME function-parameters? typename? (EXTERNAL VARARGS?)? function-body
function-parameters ::= OPEN_BRACE (variable-loose COMMA?)* CLOSE_BRACE
function-body ::= function-value-body | function-declaration-body
function-value-body ::= FUNC_DASH expression
function-declaration-body ::= code
function-loose ::= FUNC_DECL? function
function-strict ::= FUNC_DECL function

body ::= (body-line COMMA?)*
body-line ::=
      body-if
    | body-for
    | body-block
    | body-statement
    | variable-strict
    | body-assign
    | expression
    | function-strict
    | COMMENT

body-if ::= IF_DECL expression code
body-for ::= FOR_DECL expression? code
body-block ::= (BLOCK_DECL | EXIT_DECL) code
body-assign ::= expression body-assign-op expression
body-assign-op ::=
      OP_EQUALS
    | OP_ADD_EQUALS
    | OP_SUB_EQUALS
    | OP_MUL_EQUALS
    | OP_DIV_EQUALS
    | OP_MOD_EQUALS
body-statement ::= (RETURN_DECL expression) | BREAK_DECL | CONTINUE_DECL

code ::= OPEN_BODY body CLOSE_BODY